initSidebarItems({"constant":[["CONTEXT_NO_DEFAULT_INCLUDES","Create this context with an empty include path."],["CONTEXT_NO_ENVIRONMENT_NAMES","Don't take RMLVO names from the environment."],["CONTEXT_NO_FLAGS","Do not apply any context flags."],["KEYCODE_INVALID",""],["KEYCODE_MAX",""],["KEYMAP_COMPILE_NO_FLAGS","Do not apply any flags."],["KEYMAP_FORMAT_TEXT_V1","The current/classic XKB text format, as generated by xkbcomp -xkb."],["KEYMAP_FORMAT_USE_ORIGINAL","Get the keymap as a string in the format from which it was created."],["KEYSYM_CASE_INSENSITIVE",""],["KEYSYM_NO_FLAGS",""],["LAYOUT_INVALID",""],["LED_INVALID",""],["LED_NAME_CAPS",""],["LED_NAME_NUM",""],["LED_NAME_SCROLL",""],["LEVEL_INVALID",""],["MOD_INVALID",""],["MOD_NAME_ALT",""],["MOD_NAME_CAPS",""],["MOD_NAME_CTRL",""],["MOD_NAME_LOGO",""],["MOD_NAME_NUM",""],["MOD_NAME_SHIFT",""],["STATE_LAYOUT_DEPRESSED","Depressed layout, i.e. a key is physically holding it."],["STATE_LAYOUT_EFFECTIVE","Effective layout, i.e. currently active and affects key processing (derived from the other state components). Use this unless you explictly care how the state came about."],["STATE_LAYOUT_LATCHED","Latched layout, i.e. will be unset after the next non-modifier key press."],["STATE_LAYOUT_LOCKED","Locked layout, i.e. will be unset after the key provoking the lock has been pressed again."],["STATE_LEDS","LEDs (derived from the other state components)."],["STATE_MATCH_ALL","Returns true if all of the modifiers are active."],["STATE_MATCH_ANY","Returns true if any of the modifiers are active."],["STATE_MATCH_NON_EXCLUSIVE","Makes matching non-exclusive, i.e. will not return false if a modifier not specified in the arguments is active."],["STATE_MODS_DEPRESSED","Depressed modifiers, i.e. a key is physically holding them."],["STATE_MODS_EFFECTIVE","Effective modifiers, i.e. currently active and affect key processing (derived from the other state components). Use this unless you explictly care how the state came about."],["STATE_MODS_LATCHED","Latched modifiers, i.e. will be unset after the next non-modifier key press."],["STATE_MODS_LOCKED","Locked modifiers, i.e. will be unset after the key provoking the lock has been pressed again."]],"enum":[["KeyDirection","Specifies the direction of the key (press / release)."],["LogLevel",""]],"fn":[["keycode_is_legal_ext","Test whether a value is a valid extended keycode. @sa xkb_keycode_t"],["keycode_is_legal_x11","Names to compile a keymap with, also known as RMLVO.The names are the common configuration values by which a user picks a keymap.If the entire struct is NULL, then each field is taken to be NULL. You should prefer passing NULL instead of choosing your own defaults."],["keysym_from_name","Get a keysym from its name. name The name of a keysym. See remarks in xkb_keysym_get_name(); this function will accept any name returned by that function.  flags A set of flags controlling how the search is done. If invalid flags are passed, this will fail with xkb::KEY_NoSymbol.If you use the xkb::KEYSYM_CASE_INSENSITIVE flag and two keysym names differ only by case, then the lower-case keysym is returned.  For instance, for KEY_a and KEY_A, this function would return KEY_a for the case-insensitive search.  If this functionality is needed, it is recommended to first call this function without this flag; and if that fails, only then to try with this flag, while possibly warning the user he had misspelled the name, and might get wrong results.Returns The keysym. If the name is invalid, returns xkb::KEY_NoSymbol."],["keysym_get_name","Get the name of a keysym."],["keysym_to_utf32","Get the Unicode/UTF-32 representation of a keysym.Returns The Unicode/UTF-32 representation of keysym, which is also compatible with UCS-4.  If the keysym does not have a Unicode representation, returns 0.Prefer not to use this function on keysyms obtained from an xkb_state.  In this case, use xkb_state_key_get_utf32() instead."],["keysym_to_utf8","Get the Unicode/UTF-8 representation of a keysym.Prefer not to use this function on keysyms obtained from an xkb_state.  In this case, use xkb_state_key_get_utf8() instead."]],"mod":[["ffi",""],["keysyms",""],["x11",""]],"struct":[["Context","Top level library context object.The context contains various general library data and state, like logging level and include paths.Objects are created in a specific context, and multiple contexts may coexist simultaneously.  Objects from different contexts are completely separated and do not share any memory or state."],["ContextIncludePaths","Iterator to a Context include paths"],["Keymap","Compiled keymap object.The keymap object holds all of the static keyboard information obtained from compiling XKB files.A keymap is immutable after it is created (besides reference counts, etc.); if you need to change it, you must create a new one."],["KeymapLayouts","iterator to the layouts in Keymap"],["KeymapLeds","iterator to the leds in a Keymap"],["KeymapMods","iterator to the modifiers in a Keymap"],["State","Keyboard state object.State objects contain the active state of a keyboard (or keyboards), such as the currently effective layout and the active modifiers.  It acts as a simple state machine, wherein key presses and releases are the input, and key symbols (keysyms) are the output."]],"type":[["ContextFlags","Flags for context creation."],["Keycode","A number used to represent a physical key on a keyboard.A standard PC-compatible keyboard might have 102 keys.  An appropriate keymap would assign each of them a keycode, by which the user should refer to the key throughout the library.Historically, the X11 protocol, and consequentially the XKB protocol, assign only 8 bits for keycodes.  This limits the number of different keys that can be used simultaneously in a single keymap to 256 (disregarding other limitations).  This library does not share this limit; keycodes beyond 255 ('extended keycodes') are not treated specially. Keymaps and applications which are compatible with X11 should not use these keycodes.The values of specific keycodes are determined by the keymap and the underlying input system.  For example, with an X11-compatible keymap and Linux evdev scan codes (see linux/input.h), a fixed offset is used:let keycode_A: Keycode = KEY_A + 8;See `xkb::keycode_is_legal_ext()` and `xkb::keycode_is_legal_x11()`"],["KeymapCompileFlags","Flags for keymap compilation."],["KeymapFormat","The possible keymap formats."],["Keysym","A number used to represent the symbols generated from a key on a keyboard.A key, represented by a keycode, may generate different symbols according to keyboard state.  For example, on a QWERTY keyboard, pressing the key labled <A> generates the symbol 'a'.  If the Shift key is held, it generates the symbol 'A'.  If a different layout is used, say Greek, it generates the symbol 'Î±'.  And so on.Each such symbol is represented by a keysym.  Note that keysyms are somewhat more general, in that they can also represent some \"function\", such as \"Left\" or \"Right\" for the arrow keys.  For more information, see: http://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html#keysym_encodingSpecifically named keysyms can be found in the xkbcommon/xkbcommon-keysyms.h header file.  Their name does not include the xkb::KEY_ prefix.Besides those, any Unicode/ISO 10646 character in the range U0100 to U10FFFF can be represented by a keysym value in the range 0x01000100 to 0x0110FFFF.  The name of Unicode keysyms is \"U<codepoint>\", e.g. \"UA1B2\".The name of other unnamed keysyms is the hexadecimal representation of their value, e.g. \"0xabcd1234\".Keysym names are case-sensitive."],["KeysymFlags",""],["LayoutIndex","Index of a keyboard layout.The layout index is a state component which detemines which _keyboard layout_ active.  These may be different alphabets, different key arrangements, etc.Layout indices are consecutive.  The first layout has index 0.Each layout is not required to have a name, and the names are not guaranteed to be unique (though they are usually provided and unique). Therefore, it is not safe to use the name as a unique identifier for a layout.  Layout names are case-sensitive.Layouts are also called \"groups\" by XKB."],["LayoutMask","A mask of layout indices"],["LedIndex","Index of a keyboard LED.LEDs are logical objects which may be  active or  inactive.  They typically correspond to the lights on the keyboard. Their state is determined by the current keyboard state.LED indices are non-consecutive.  The first LED has index 0.Each LED must have a name, and the names are unique. Therefore, it is safe to use the name as a unique identifier for a LED.  The names of some common LEDs are provided in the xkbcommon/xkbcommon-names.h header file.  LED names are case-sensitive.@warning A given keymap may specify an exact index for a given LED. Therefore, LED indexing is not necessarily sequential, as opposed to modifiers and layouts.  This means that when iterating over the LEDs in a keymap using e.g. xkb_keymap_num_leds(), some indices might be invalid.  Given such an index, functions like xkb_keymap_led_get_name() will return NULL, and xkb_state_led_index_is_active() will return -1.LEDs are also called \"indicators\" by XKB."],["LedMask","A mask of LED indices."],["LevelIndex","Index of a shift level.Any key, in any layout, can have several _shift levels_  Each shift level can assign different keysyms to the key.  The shift level to use is chosen according to the current keyboard state; for example, if no keys are pressed, the first level may be used; if the Left Shift key is pressed, the second; if Num Lock is pressed, the third; and many such combinations are possible (see ModIndex).Level indices are consecutive.  The first level has index 0."],["ModIndex","Index of a modifier.A modifier is a state component which changes the way keys are interpreted.  A keymap defines a set of modifiers, such as Alt, Shift, Num Lock or Meta, and specifies which keys may activate which modifiers (in a many-to-many relationship, i.e. a key can activate several modifiers, and a modifier may be activated by several keys. Different keymaps do this differently).When retrieving the keysyms for a key, the active modifier set is consulted; this detemines the correct shift level to use within the currently active layout (see LevelIndex).Modifier indices are consecutive.  The first modifier has index 0.Each modifier must have a name, and the names are unique.  Therefore, it is safe to use the name as a unique identifier for a modifier. Modifier names are case-sensitive."],["ModMask","A mask of modifier indices."],["StateComponent","Modifier and layout types for state objects.  This enum is bitmaskable, e.g. (xkb::STATE_MODS_DEPRESSED | xkb::STATE_MODS_LATCHED) is valid to exclude locked modifiers.In XKB, the DEPRESSED components are also known as 'base'."],["StateMatch","Match flags for xkb_state_mod_indices_are_active and xkb_state_mod_names_are_active, specifying how the conditions for a successful match.  xkb::STATE_MATCH_NON_EXCLUSIVE is bitmaskable with the other modes."]]});